import React, { useState, useEffect } from 'react';
import Tree from 'react-d3-tree';
import axios from 'axios';
import './App.css';

const API_URL = 'http://localhost:8000/api/goals';

// Helper to get the allowed child type for a parent
const getChildType = (parentType) => {
  const map = {
    'UltimateGoal': 'LongTermGoal',
    'LongTermGoal': 'MidTermGoal',
    'MidTermGoal': 'ShortTermGoal',
    'ShortTermGoal': 'PracticeSession',
    'PracticeSession': 'ImmediateGoal',
    'ImmediateGoal': 'MicroGoal',
    'MicroGoal': 'NanoGoal',
    'NanoGoal': null // Nano goals can't have children
  };
  return map[parentType];
};

// Helper to get human-readable name for goal type
const getTypeDisplayName = (type) => {
  const names = {
    'UltimateGoal': 'Ultimate Goal',
    'LongTermGoal': 'Long Term Goal',
    'MidTermGoal': 'Mid Term Goal',
    'ShortTermGoal': 'Short Term Goal',
    'PracticeSession': 'Practice Session',
    'ImmediateGoal': 'Immediate Goal',
    'MicroGoal': 'Micro Goal',
    'NanoGoal': 'Nano Goal'
  };
  return names[type] || type;
};

// Helper to calculate goal age
const calculateGoalAge = (createdAt) => {
  if (!createdAt) return null;

  const created = new Date(createdAt);
  const now = new Date();
  const diffMs = now - created;
  const diffDays = diffMs / (1000 * 60 * 60 * 24);

  if (diffDays >= 365) {
    // Years as a decimal when more than a single year
    return `${(diffDays / 365).toFixed(1)}y`;
  } else if (diffDays >= 30 || diffDays > 7) {
    // Months as a decimal when more than a single month OR more than a single week
    return `${(diffDays / 30.44).toFixed(1)}mo`;
  } else if (diffDays > 6) {
    // Weeks as a decimal when more than six days
    return `${(diffDays / 7).toFixed(1)}w`;
  } else {
    // Days when less than a week
    return `${Math.floor(diffDays)}d`;
  }
};

// Helper to calculate metrics for a goal tree
const calculateMetrics = (goalNode) => {
  if (!goalNode) return { totalGoals: 0, completedGoals: 0, completionPercentage: 0 };

  let totalGoals = 0;
  let completedGoals = 0;

  const traverse = (node) => {
    totalGoals++;
    if (node.attributes?.completed) {
      completedGoals++;
    }

    if (node.children && node.children.length > 0) {
      node.children.forEach(child => traverse(child));
    }
  };

  traverse(goalNode);

  const completionPercentage = totalGoals > 0 ? Math.round((completedGoals / totalGoals) * 100) : 0;

  return { totalGoals, completedGoals, completionPercentage };
};

function App() {
  const [roots, setRoots] = useState([]); // All top-level fractals
  const [selectedRootId, setSelectedRootId] = useState(null);
  const [loading, setLoading] = useState(true);
  const [showModal, setShowModal] = useState(false);
  const [selectedParent, setSelectedParent] = useState(null);

  // Goal details modal state
  const [showDetailsModal, setShowDetailsModal] = useState(false);
  const [viewingGoal, setViewingGoal] = useState(null);

  // Practice session modal state
  const [showPracticeSessionModal, setShowPracticeSessionModal] = useState(false);
  const [selectedShortTermGoals, setSelectedShortTermGoals] = useState([]);
  const [immediateGoals, setImmediateGoals] = useState([{ name: '', description: '' }]);

  // Form State
  const [name, setName] = useState('');
  const [description, setDescription] = useState('');
  const [deadline, setDeadline] = useState('');
  const [goalType, setGoalType] = useState('UltimateGoal');

  const fetchGoals = async () => {
    try {
      const res = await axios.get(API_URL);
      const fetchedRoots = res.data;
      setRoots(fetchedRoots);

      // Select first root if none selected and roots exist
      if (!selectedRootId && fetchedRoots.length > 0) {
        setSelectedRootId(fetchedRoots[0].id);
      } else if (fetchedRoots.length === 0) {
        setSelectedRootId(null);
      }
      // If currently selected root is gone (deleted?), reset? (not handling delete yet)

      setLoading(false);
    } catch (err) {
      console.error("Failed to fetch goals", err);
      setLoading(false);
    }
  };

  const [practiceSessions, setPracticeSessions] = useState([]);
  const [selectedPracticeSession, setSelectedPracticeSession] = useState(null);

  const fetchPracticeSessions = async () => {
    try {
      const res = await axios.get('http://localhost:8000/api/practice-sessions');
      setPracticeSessions(res.data);
    } catch (err) {
      console.error("Failed to fetch practice sessions", err);
    }
  };

  useEffect(() => {
    fetchGoals();
    fetchPracticeSessions();
  }, []);

  const handleAddChildClick = (nodeDatum) => {
    openModal(nodeDatum);
  };

  const handleGoalNameClick = (nodeDatum) => {
    setViewingGoal(nodeDatum);
    setShowDetailsModal(true);
  };

  const openModal = (parent) => {
    setSelectedParent(parent);
    // Smart default type selection based on parent level
    if (!parent) {
      setGoalType('UltimateGoal'); // Default for new fractal
    } else {
      const parentType = parent.attributes?.type || parent.type;
      const childType = getChildType(parentType);
      if (!childType) {
        alert('This goal type cannot have children.');
        return;
      }
      setGoalType(childType);
    }
    setShowModal(true);
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    try {
      const payload = {
        name,
        description,
        type: goalType,
        parent_id: selectedParent ? (selectedParent.attributes?.id || selectedParent.id) : null,
        deadline: deadline || null
      };

      const res = await axios.post(API_URL, payload);

      // Reset form
      setShowModal(false);
      setName('');
      setDescription('');
      setDeadline('');

      // Refresh fractal
      await fetchGoals();

      // If we created a new root, select it
      if (!selectedParent) {
        setSelectedRootId(res.data.id);
      }

    } catch (err) {
      alert('Error creating goal: ' + err.message);
    }
  };

  const handleToggleCompletion = async (goalId, currentStatus) => {
    try {
      const response = await axios.patch(`${API_URL}/${goalId}/complete`, {
        completed: !currentStatus
      });

      // Update the viewingGoal with the fresh data from the response
      if (viewingGoal && (viewingGoal.attributes?.id === goalId || viewingGoal.id === goalId)) {
        setViewingGoal(response.data.goal);
      }

      // Refresh the fractal to show updated status
      await fetchGoals();
    } catch (err) {
      alert('Error updating goal completion: ' + err.message);
    }
  };

  // Helper to collect all short-term goals from the tree
  const collectShortTermGoals = (node, collected = []) => {
    if (!node) return collected;

    const type = node.attributes?.type || node.type;
    if (type === 'ShortTermGoal') {
      collected.push({
        id: node.attributes?.id || node.id,
        name: node.name
      });
    }

    if (node.children && node.children.length > 0) {
      node.children.forEach(child => collectShortTermGoals(child, collected));
    }

    return collected;
  };

  // Helper to count practice sessions in the tree
  const countPracticeSessions = (node) => {
    if (!node) return 0;

    let count = 0;
    const type = node.attributes?.type || node.type;
    if (type === 'PracticeSession') {
      count = 1;
    }

    if (node.children && node.children.length > 0) {
      node.children.forEach(child => {
        count += countPracticeSessions(child);
      });
    }

    return count;
  };

  // Helper function to wrap text
  const wrapText = (text, maxCharsPerLine = 20) => {
    const words = text.split(' ');
    const lines = [];
    let currentLine = '';

    words.forEach(word => {
      const testLine = currentLine ? `${currentLine} ${word}` : word;
      if (testLine.length > maxCharsPerLine && currentLine) {
        lines.push(currentLine);
        currentLine = word;
      } else {
        currentLine = testLine;
      }
    });

    if (currentLine) {
      lines.push(currentLine);
    }

    return lines;
  };

  // Custom Node to show details
  const renderCustomNode = ({ nodeDatum, toggleNode }) => {
    const nameLines = wrapText(nodeDatum.name, 50);
    const lineHeight = 16;
    const startY = -5 - ((nameLines.length - 1) * lineHeight / 2); // Center multi-line text
    const isCompleted = nodeDatum.attributes?.completed || false;

    return (
      <g>
        {/* Node Circle */}
        <circle
          r={15}
          fill={nodeDatum.children && nodeDatum.children.length > 0 ? "#4caf50" : "#2196f3"}
          stroke="#fff"
          strokeWidth="2"
          onClick={toggleNode}
          opacity={isCompleted ? 0.5 : 1}
        />

        {/* Node Name - wrapped */}
        <text
          fill="#e0e0e0"
          strokeWidth="0"
          x="20"
          fontSize="14"
          fontWeight="600"
          onClick={() => handleGoalNameClick(nodeDatum)}
          style={{
            cursor: 'pointer',
            textShadow: '0 1px 3px rgba(0,0,0,0.8)',
            textDecoration: isCompleted ? 'line-through' : 'none',
            opacity: isCompleted ? 0.6 : 1
          }}
        >
          {nameLines.map((line, index) => (
            <tspan key={index} x="20" dy={index === 0 ? startY : lineHeight}>
              {line}
            </tspan>
          ))}
        </text>

        {/* Goal Age - for goals down to ShortTermGoal */}
        {(() => {
          const type = nodeDatum.attributes?.type || nodeDatum.type;
          const showAge = ["UltimateGoal", "LongTermGoal", "MidTermGoal", "ShortTermGoal"].includes(type);
          const age = calculateGoalAge(nodeDatum.attributes?.created_at);

          if (!showAge || !age) return null;

          const ageY = startY + (nameLines.length * lineHeight) + 0;

          return (
            <text
              fill="#fff"
              className="add-child-text"
              x="20"
              dy={ageY}
              fontSize="12"
              fontWeight="bold"
              style={{ fill: 'white', stroke: 'none' }}
            >
              {age}
            </text>
          );
        })()}

        {/* Add Child Button */}
        {(() => {
          const parentType = nodeDatum.attributes?.type || nodeDatum.type;
          const childType = getChildType(parentType);
          if (!childType) return null; // Don't show button if no children allowed

          const type = nodeDatum.attributes?.type || nodeDatum.type;
          const hasAge = ["UltimateGoal", "LongTermGoal", "MidTermGoal", "ShortTermGoal"].includes(type) && nodeDatum.attributes?.created_at;

          let offset = 12;
          if (hasAge) offset += 6; // More space after age

          const buttonY = startY + (nameLines.length * lineHeight) + offset;

          return (
            <text
              fill="#fff"
              className="add-child-text"
              x="20"
              dy={buttonY}
              fontSize="12"
              fontWeight="bold"
              onClick={() => handleAddChildClick(nodeDatum)}
              style={{ cursor: 'pointer', textDecoration: 'underline', fill: 'white', stroke: 'none' }}
            >
              + Add {getTypeDisplayName(childType)}
            </text>
          );
        })()}
      </g>
    );
  };

  // Delete Modal State
  const [fractalToDelete, setFractalToDelete] = useState(null);

  const selectedFractalData = roots.find(r => r.id === selectedRootId);

  const handleDeleteFractal = (e, fractalId, fractalName) => {
    e.stopPropagation();
    setFractalToDelete({ id: fractalId, name: fractalName });
  };

  const confirmDeleteFractal = async () => {
    if (!fractalToDelete) return;

    try {
      await axios.delete(`${API_URL}/${fractalToDelete.id}`);

      if (selectedRootId === fractalToDelete.id) {
        const remaining = roots.filter(r => r.id !== fractalToDelete.id);
        setSelectedRootId(remaining.length > 0 ? remaining[0].id : null);
      }

      await fetchGoals();
      setFractalToDelete(null);
    } catch (err) {
      alert('Failed to delete fractal: ' + err.message);
    }
  };

  return (
    <div className="app-container">
      <div className="top-section">
        <div className="main-content">
          {loading ? <p>Loading...</p> : (
            selectedFractalData ? (
              <>
                {/* Metrics Overlay */}
                {(() => {
                  const metrics = calculateMetrics(selectedFractalData);
                  return (
                    <div className="metrics-overlay">
                      <div className="metric-item">{metrics.totalGoals} goals</div>
                      <div className="metric-item">{metrics.completionPercentage}% complete</div>
                    </div>
                  );
                })()}

                <Tree
                  data={selectedFractalData}
                  orientation="vertical"
                  pathFunc="straight"
                  translate={{ x: 400, y: 50 }}
                  renderCustomNodeElement={renderCustomNode}
                  collapsible={true}
                  separation={{ siblings: 2, nonSiblings: 2 }}
                  nodeSize={{ x: 200, y: 150 }}
                  key={selectedRootId} // Force re-render on switch
                />
              </>
            ) : (
              <div className="empty-state">
                <h2>No Goals Created Yet</h2>
                <button onClick={() => openModal(null)}>Create Your First Goal Fractal</button>
              </div>
            )
          )}
        </div>

        <div className="sidebar">
          <h3>My Goal Fractals</h3>
          <ul className="fractal-list">
            {roots.map(root => (
              <li
                key={root.id}
                className={root.id === selectedRootId ? 'active' : ''}
                onClick={() => setSelectedRootId(root.id)}
              >
                <span className="fractal-name">{root.name}</span>
                <button
                  className="delete-fractal-btn"
                  onClick={(e) => handleDeleteFractal(e, root.id, root.name)}
                  title="Delete Fractal"
                >
                  Ã—
                </button>
              </li>
            ))}
          </ul>
          <button className="create-fractal-btn" onClick={() => openModal(null)}>+ New Fractal</button>

          {/* Add Practice Session button - shown when a fractal is selected */}
          {selectedRootId && (
            <button
              className="practice-session-btn"
              onClick={() => {
                const selectedRoot = roots.find(r => r.id === selectedRootId);
                if (selectedRoot) {
                  // Reset form state and open modal
                  setSelectedShortTermGoals([]);
                  setImmediateGoals([{ name: '', description: '' }]);
                  setShowPracticeSessionModal(true);
                }
              }}
            >
              + Add a Practice Session
            </button>
          )}
        </div>
      </div>

      {/* Practice Sessions Grid */}
      <div className="practice-sessions-grid">
        <h3>Practice Sessions</h3>
        <div className="sessions-grid-container">
          {practiceSessions.length === 0 ? (
            <p className="no-sessions-message">No practice sessions yet. Create one to get started!</p>
          ) : (
            practiceSessions.map(session => (
              <div
                key={session.id}
                className={`session-square ${selectedPracticeSession?.id === session.id ? 'selected' : ''}`}
                onClick={() => setSelectedPracticeSession(session)}
              >
                <div className="session-name">{session.name}</div>
                <div className="session-meta">
                  {session.attributes.parent_ids?.length || 0} goal{session.attributes.parent_ids?.length !== 1 ? 's' : ''}
                </div>
              </div>
            ))
          )}
        </div>
      </div>

      {showModal && (
        <div className="modal-overlay">
          <div className="modal">
            <h2>{selectedParent ? `Add ${getTypeDisplayName(goalType)} under "${selectedParent.name}"` : "Create New Fractal"}</h2>
            <form onSubmit={handleSubmit}>
              <label>Type:</label>
              {selectedParent ? (
                <div style={{ padding: '10px', background: '#f5f5f5', borderRadius: '4px', color: '#333', fontWeight: 'bold' }}>
                  {getTypeDisplayName(goalType)}
                </div>
              ) : (
                <select
                  value={goalType}
                  onChange={e => setGoalType(e.target.value)}
                  style={{ padding: '10px', background: '#1e1e1e', border: '1px solid #454545', borderRadius: '6px', color: 'white' }}
                >
                  <option value="UltimateGoal">Ultimate Goal</option>
                  <option value="LongTermGoal">Long Term Goal</option>
                  <option value="MidTermGoal">Mid Term Goal</option>
                  <option value="ShortTermGoal">Short Term Goal</option>
                </select>
              )}

              <label>Name:</label>
              <input value={name} onChange={e => setName(e.target.value)} required />

              <label>Description:</label>
              <textarea value={description} onChange={e => setDescription(e.target.value)} />

              <label>Deadline:</label>
              <input type="date" value={deadline} onChange={e => setDeadline(e.target.value)} />

              <div className="actions">
                <button type="button" onClick={() => setShowModal(false)}>Cancel</button>
                <button type="submit">Create</button>
              </div>
            </form>
          </div>
        </div>
      )}



      {fractalToDelete && (
        <div className="modal-overlay">
          <div className="modal">
            <h2>Delete {selectedRootId === fractalToDelete.id ? "Fractal" : "Goal"}?</h2>
            <p>Are you sure you want to delete <strong>"{fractalToDelete.name}"</strong>?</p>
            <p style={{ color: '#ff5252', fontSize: '0.9rem' }}>This action cannot be undone.</p>
            <div className="actions">
              <button type="button" onClick={() => setFractalToDelete(null)}>Cancel</button>
              <button
                type="button"
                onClick={confirmDeleteFractal}
                style={{ background: '#d32f2f', color: 'white', border: 'none' }}
              >
                Delete
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Goal Details Modal */}
      {showDetailsModal && viewingGoal && (
        <div className="modal-overlay" onClick={() => setShowDetailsModal(false)}>
          <div className="modal details-modal" onClick={(e) => e.stopPropagation()}>
            <h2>{viewingGoal?.name}</h2>
            <div className="modal-content-scroll">
              <p><strong>Type:</strong> {viewingGoal?.attributes?.type || viewingGoal?.type}</p>
              <p><strong>Created:</strong> {viewingGoal?.attributes?.created_at ? new Date(viewingGoal.attributes.created_at).toLocaleDateString() : 'Unknown'}
                {viewingGoal?.attributes?.created_at && ` (${calculateGoalAge(viewingGoal.attributes.created_at)})`}
              </p>
              <p><strong>Description:</strong> {viewingGoal?.attributes?.description || viewingGoal?.description || 'No description'}</p>
              {(viewingGoal?.attributes?.deadline || viewingGoal?.deadline) && (
                <p><strong>Deadline:</strong> {viewingGoal?.attributes?.deadline || viewingGoal?.deadline}</p>
              )}

              <h4>Immediate Children:</h4>
              {viewingGoal?.children && viewingGoal.children.length > 0 ? (
                <ul className="children-list">
                  {viewingGoal.children.map(child => (
                    <li key={child.attributes?.id || child.id}>
                      <strong>{child.name}</strong> ({getTypeDisplayName(child.attributes?.type || child.type)})
                    </li>
                  ))}
                </ul>
              ) : (
                <p className="no-children">No children yet.</p>
              )}

              <div className="completion-section">
                <label className="completion-label">
                  <input
                    type="checkbox"
                    checked={viewingGoal?.attributes?.completed || false}
                    onChange={() => {
                      const goalId = viewingGoal?.attributes?.id || viewingGoal?.id;
                      const currentStatus = viewingGoal?.attributes?.completed || false;
                      handleToggleCompletion(goalId, currentStatus);
                    }}
                  />
                  <span>
                    Mark as {viewingGoal?.attributes?.completed ? 'Incomplete' : 'Completed'}
                  </span>
                </label>
              </div>
            </div>

            <div className="modal-actions">
              {(() => {
                const parentType = viewingGoal?.attributes?.type || viewingGoal?.type;
                const childType = getChildType(parentType);
                if (childType) {
                  return (
                    <button
                      className="action-btn primary"
                      onClick={() => {
                        setShowDetailsModal(false);
                        handleAddChildClick(viewingGoal);
                      }}
                    >
                      + Add Child
                    </button>
                  );
                }
                return null;
              })()}
              <button
                className="action-btn danger"
                onClick={() => {
                  const goalId = viewingGoal?.attributes?.id || viewingGoal?.id;
                  setShowDetailsModal(false);
                  setFractalToDelete({
                    id: goalId,
                    name: viewingGoal?.name
                  });
                }}
              >
                Delete Goal
              </button>
              <button
                type="button"
                onClick={() => setShowDetailsModal(false)}
                style={{ marginTop: '10px' }}
              >
                Close
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

export default App;
